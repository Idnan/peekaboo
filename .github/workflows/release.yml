name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true

env:
  APP_NAME: Peekaboo
  SCHEME: Peekaboo

jobs:
  build:
    runs-on: macos-14
    permissions:
      contents: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set version from tag or input
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_ENV
          else
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_ENV
          fi

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Install tools
        run: |
          brew install create-dmg
          # Download Sparkle for signing tools
          curl -L -o /tmp/Sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.6.4/Sparkle-2.6.4.tar.xz
          mkdir -p /tmp/Sparkle
          tar -xf /tmp/Sparkle.tar.xz -C /tmp/Sparkle

      - name: Install Apple certificate
        env:
          P12_BASE64: ${{ secrets.DEVELOPER_ID_APPLICATION_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.DEVELOPER_ID_APPLICATION_P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ github.run_id }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Decode certificate
          echo "$P12_BASE64" | base64 --decode > $CERTIFICATE_PATH
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH -T /usr/bin/codesign -T /usr/bin/security
          
          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Add keychain to search list (prepend to make it first)
          security list-keychain -d user -s $KEYCHAIN_PATH $(security list-keychain -d user | tr -d '"')
          
          # Set as default keychain
          security default-keychain -s $KEYCHAIN_PATH
          
          # Verify certificate is installed
          echo "Installed certificates:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Update version in project
        run: |
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" Peekaboo/Resources/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" Peekaboo/Resources/Info.plist

      - name: Resolve Swift Package Dependencies
        run: xcodebuild -resolvePackageDependencies -project ${{ env.APP_NAME }}.xcodeproj -scheme ${{ env.SCHEME }}

      - name: Build
        run: |
          xcodebuild -project ${{ env.APP_NAME }}.xcodeproj \
            -scheme ${{ env.SCHEME }} \
            -configuration Release \
            -derivedDataPath build \
            -arch arm64 -arch x86_64 \
            ONLY_ACTIVE_ARCH=NO \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            build

      - name: Sign app bundle
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          KEYCHAIN_PATH: ${{ runner.temp }}/app-signing.keychain-db
        run: |
          APP_PATH="build/Build/Products/Release/${{ env.APP_NAME }}.app"
          
          # Find the exact certificate name
          CERT_NAME=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          echo "Using certificate: $CERT_NAME"
          
          # Sign all nested components first (Sparkle XPC services, helpers, etc.)
          find "$APP_PATH" -type f \( -name "*.dylib" -o -perm +111 \) | while read -r binary; do
            echo "Signing: $binary"
            codesign --force --options runtime --timestamp --sign "$CERT_NAME" --keychain "$KEYCHAIN_PATH" "$binary" 2>/dev/null || true
          done
          
          # Sign XPC services
          find "$APP_PATH" -name "*.xpc" -type d | while read -r xpc; do
            echo "Signing XPC: $xpc"
            codesign --force --options runtime --timestamp --sign "$CERT_NAME" --keychain "$KEYCHAIN_PATH" "$xpc"
          done
          
          # Sign nested apps (like Sparkle Updater.app)
          find "$APP_PATH" -name "*.app" -type d -mindepth 1 | while read -r nested_app; do
            echo "Signing nested app: $nested_app"
            codesign --force --options runtime --timestamp --sign "$CERT_NAME" --keychain "$KEYCHAIN_PATH" "$nested_app"
          done
          
          # Sign frameworks
          find "$APP_PATH" -name "*.framework" -type d | while read -r framework; do
            echo "Signing framework: $framework"
            codesign --force --options runtime --timestamp --sign "$CERT_NAME" --keychain "$KEYCHAIN_PATH" "$framework"
          done
          
          # Finally sign the main app
          codesign --force --options runtime --timestamp --sign "$CERT_NAME" --keychain "$KEYCHAIN_PATH" "$APP_PATH"
          
          # Verify
          echo "Verifying signature..."
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="build/Build/Products/Release/${{ env.APP_NAME }}.app"
          
          # Create ZIP for notarization
          ditto -c -k --keepParent "$APP_PATH" "/tmp/notarize.zip"
          
          # Submit for notarization and capture output
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "/tmp/notarize.zip" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$TEAM_ID" \
            --wait 2>&1) || true
          
          echo "$SUBMISSION_OUTPUT"
          
          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          
          # Check if notarization succeeded
          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo "Notarization successful!"
            xcrun stapler staple "$APP_PATH"
          else
            echo "Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_ID_PASSWORD" \
              --team-id "$TEAM_ID" \
              notarization-log.json
            cat notarization-log.json
            exit 1
          fi

      - name: Create DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="build/Build/Products/Release/${{ env.APP_NAME }}.app"
          DMG_NAME="${{ env.APP_NAME }}-${{ env.VERSION }}.dmg"
          
          create-dmg \
            --volname "${{ env.APP_NAME }}" \
            --volicon "$APP_PATH/Contents/Resources/AppIcon.icns" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "${{ env.APP_NAME }}.app" 150 185 \
            --hide-extension "${{ env.APP_NAME }}.app" \
            --app-drop-link 450 185 \
            "$DMG_NAME" \
            "$APP_PATH" || true
          
          # Fallback if create-dmg fails
          if [ ! -f "$DMG_NAME" ]; then
            hdiutil create -volname "${{ env.APP_NAME }}" -srcfolder "$APP_PATH" -ov -format UDZO "$DMG_NAME"
          fi
          
          # Sign and notarize the DMG too
          KEYCHAIN_PATH=${{ runner.temp }}/app-signing.keychain-db
          CERT_NAME=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          codesign --force --sign "$CERT_NAME" --keychain "$KEYCHAIN_PATH" "$DMG_NAME"
          xcrun notarytool submit "$DMG_NAME" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$TEAM_ID" \
            --wait
          xcrun stapler staple "$DMG_NAME"

      - name: Create ZIP
        run: |
          APP_PATH="build/Build/Products/Release/${{ env.APP_NAME }}.app"
          ZIP_NAME="${{ env.APP_NAME }}-${{ env.VERSION }}.zip"
          cd "build/Build/Products/Release"
          ditto -c -k --keepParent "${{ env.APP_NAME }}.app" "../../../../$ZIP_NAME"

      - name: Sign update and generate appcast
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          # Write private key to temp file
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "::error::SPARKLE_PRIVATE_KEY secret not set"
            exit 1
          fi
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_private_key
          
          # Generate appcast item using script
          ZIP_NAME="${{ env.APP_NAME }}-${{ env.VERSION }}.zip"
          ./scripts/generate-appcast.sh "${{ env.VERSION }}" "$ZIP_NAME" "https://github.com/${{ github.repository }}" /tmp/sparkle_private_key > /tmp/new_item.xml
          
          # Clean up private key
          rm -f /tmp/sparkle_private_key
          
          cat /tmp/new_item.xml

      - name: Commit updated appcast
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch latest main and apply change there
          git fetch origin main
          git checkout main
          
          # Insert new item into appcast.xml after <language>en</language>
          sed -i '' '/<language>en<\/language>/r /tmp/new_item.xml' appcast.xml
          rm -f /tmp/new_item.xml
          
          cat appcast.xml
          
          git add appcast.xml
          git diff --cached --quiet || git commit -m "Update appcast.xml for v${{ env.VERSION }}"
          git push origin main

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            *.dmg
            *.zip

      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            *.dmg
            *.zip
          draft: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

